// Copyright by https://github.com/sabhiram/gover

package utils

import (
	"errors"
	"fmt"
	"html/template"
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

const version_filename = "Version.go"

const (
	tmpl = `package {{ .PackageName }}
// WARNING: Auto generated version file. Do not edit this file by hand.
// Version: {{ .Major }}.{{ .Minor }}.{{ .Patch }}
const (
	Major = {{ .Major }}
	Minor = {{ .Minor }}
	Patch = {{ .Patch }}
	Version = "{{ .Major }}.{{ .Minor }}.{{ .Patch }}"
)
`
	versionKey = "// Version: "
	packageKey = "package "
)

// Version encapsulates a semantic version as well as a package name.
type Version struct {
	filepath    string
	PackageName string
	Major       uint64
	Minor       uint64
	Patch       uint64
}

func (v *Version) unmarshalSemVer(s string) error {
	var err error

	items := strings.Split(s, ".")
	if len(items) < 3 {
		return fmt.Errorf("%s is an invalid version", s)
	}

	v.Major, err = strconv.ParseUint(items[0], 10, 64)
	if err != nil {
		return err
	}

	v.Minor, err = strconv.ParseUint(items[1], 10, 64)
	if err != nil {
		return err
	}

	v.Patch, err = strconv.ParseUint(items[2], 10, 64)
	return err
}

func (v *Version) incrMajor() {
	v.Major += 1
	v.Minor = 0
	v.Patch = 0
}

func (v *Version) incrMinor() {
	v.Minor += 1
	v.Patch = 0
}

func (v *Version) incrPatch() {
	v.Patch += 1
}

func (v *Version) update() error {
	t, err := template.New("version").Parse(tmpl)
	if err != nil {
		return err
	}
	file := filepath.Join(filepath.Base(v.filepath), version_filename)
	f, err := os.Create(file)
	if err != nil {
		return err
	}
	defer f.Close()

	return t.Execute(f, v)
}

// String implements the stringer interface for `Version`.
func (v *Version) String() string {
	if v == nil {
		return ""
	}
	return fmt.Sprintf("%d.%d.%d", v.Major, v.Minor, v.Patch)
}

// Init initializes a `Version.go` file with the specified version string
// and package name.
func VersionInit(vs, pn string, path ...string) error {
	v := &Version{filepath: Param(path, "")}
	if err := v.unmarshalSemVer(vs); err != nil {
		return err
	}
	v.PackageName = pn

	return v.update()
}

// Load reads `Version.go` in the current directory and loads it into a
// `*Version` instance.
func VersionLoad(path ...string) (*Version, error) {
	p := Param(path, "")
	file := filepath.Join(filepath.Base(p), version_filename)
	bs, err := ioutil.ReadFile(file)
	if err != nil {
		return nil, err
	}

	fc := string(bs)
	v := &Version{
		PackageName: "main",
	}

	if idx := strings.Index(fc, packageKey); idx >= 0 {
		pkg := fc[idx+len(packageKey):]
		if idx = strings.Index(pkg, "\n"); idx >= 0 {
			pkg = pkg[:idx]
		}
		v.PackageName = pkg
	}

	if idx := strings.Index(fc, versionKey); idx >= 0 {
		ver := fc[idx+len(versionKey):]
		if idx = strings.Index(ver, "\n"); idx >= 0 {
			ver = ver[:idx]
		}
		return v, v.unmarshalSemVer(ver)
	}

	return nil, errors.New("version not found in file")
}

// Increment loads the version from the current directory and updates the
// appropriate component of the semantic version (major, minor or patch).
func VersionIncrement(op string, path ...string) error {
	v, err := VersionLoad(path...)
	if err != nil {
		return err
	}

	switch op {
	case "major":
		v.incrMajor()
	case "minor":
		v.incrMinor()
	case "patch":
		v.incrPatch()
	default:
		return fmt.Errorf("cannot increment %s", op)
	}

	return v.update()
}
